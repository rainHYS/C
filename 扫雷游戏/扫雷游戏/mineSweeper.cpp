#include <iostream>
using namespace std;
// 题目描述：
// 扫雷游戏是一款十分经典的单机小游戏。在n行m列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。
// 玩家翻开一个非地雷格时，该格将会出现一个数字一一提示周围格子中有多少个是地雷格。
// 游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。
// 现在给出n行m列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。
// 注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。
// 对于100% 的数据，1 <= n <= 100，1 <= m <= 100.

// 输入：
// 第一行是用一个空格隔开的两个整数n和m，分别表示雷区的行数和列数。
// 接下来n行，每行m个字符，描述了雷区中的地雷分布情况。
// 字符* 表示相应格子是地雷格，字符？表示相应格子是非地雷格。相邻字符之间无分隔符。

// 输出：
// 输出文件包含n行，每行m个字符，描述整个雷区。
// 用* 表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。

int main() {
    // 声明两个整数变量n和m，分别表示地雷区的行数和列数
    int n, m;
    // 从标准输入读取用户输入的值，分别赋值给n和m
    cin >> n >> m;


    // 动态分配一个指针数组，数组大小为n（行数），每个元素是一个char*指针
    char** mineField = new char* [n];
    // 遍历每一行，为每一行动态分配一个char数组，数组大小为m（列数）
    for (int i = 0; i < n; i++) {
        mineField[i] = new char[m];
    }

    // 开始读取用户输入的雷区
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> mineField[i][j]; // 读取每个格子的字符（* 或 ?）
        }
    }

    // 开始检验每个位置旁边有多少颗雷
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            // 如果当前格子不是地雷格（*），则计算周围地雷的数量
            if (mineField[i][j] != '*') {
                int mineNum = 0; // 初始化地雷计数器
                // 遍历当前格子的周围8个格子
                for (int k = i - 1; k <= i + 1; k++) {
                    for (int l = j - 1; l <= j + 1; l++) {
                        // 检查边界条件：确保k和l在合法范围内
                        if (k >= 0 && k < n && l >= 0 && l < m) {
                            // 如果周围格子是地雷格（*），则地雷计数器加1
                            if (mineField[k][l] == '*') {
                                mineNum++;
                            }
                        }
                    }
                }
                // 将地雷数量转换为字符并存储到当前格子
                // '0' + mineNum 是将数字转换为对应的字符（例如，1 -> '1'，2 -> '2'）
                mineField[i][j] = '0' + mineNum;
            }
        }
    }

    // 输出最终的地雷分布结果
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cout << mineField[i][j] << " "; // 输出每个格子的字符
        }
        cout << endl; // 换行
    }

    return 0;
}